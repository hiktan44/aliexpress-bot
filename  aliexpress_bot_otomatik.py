#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
AliExpress Bot - Otomatik CAPTCHA √á√∂zme ile
6000+ √ºr√ºn i√ßin uygun, tam otomatik sistem
"""

import pandas as pd
import time
import random
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains
from webdriver_manager.chrome import ChromeDriverManager
import os
import logging
import requests
import base64
from PIL import Image
from io import BytesIO
import cv2
import numpy as np

class OtomatikCaptchaCozucu:
    """Otomatik CAPTCHA √ß√∂zme sistemi"""
    
    def __init__(self, driver):
        self.driver = driver
        self.logger = logging.getLogger(__name__)
    
    def solve_checkbox_captcha(self):
        """'Ben robot deƒüilim' checkbox CAPTCHA √ß√∂zer"""
        try:
            # Checkbox CAPTCHA selectors
            checkbox_selectors = [
                "input[type='checkbox']",
                ".recaptcha-checkbox",
                "[class*='checkbox']",
                "#recaptcha-anchor"
            ]
            
            for selector in checkbox_selectors:
                try:
                    checkbox = WebDriverWait(self.driver, 3).until(
                        EC.element_to_be_clickable((By.CSS_SELECTOR, selector))
                    )
                    
                    # ƒ∞nsan benzeri tƒ±klama
                    actions = ActionChains(self.driver)
                    actions.move_to_element(checkbox)
                    actions.pause(random.uniform(0.5, 1.5))
                    actions.click()
                    actions.perform()
                    
                    time.sleep(random.uniform(2, 4))
                    print("‚úÖ Checkbox CAPTCHA √ß√∂z√ºld√º")
                    return True
                    
                except:
                    continue
            
            return False
            
        except Exception as e:
            self.logger.warning(f"Checkbox CAPTCHA hatasƒ±: {e}")
            return False
    
    def solve_slider_captcha(self):
        """Slider (kaydƒ±rma) CAPTCHA √ß√∂zer"""
        try:
            # Slider selectors
            slider_selectors = [
                ".nc_iconfont",
                "[class*='slider']",
                "[class*='slide']",
                ".captcha-slider",
                "#nc_1_n1t"
            ]
            
            for selector in slider_selectors:
                try:
                    slider = self.driver.find_element(By.CSS_SELECTOR, selector)
                    
                    # Slider'ƒ± saƒüa kaydƒ±r
                    actions = ActionChains(self.driver)
                    actions.click_and_hold(slider)
                    
                    # ƒ∞nsan benzeri hareket - yava≈ü ve titrek
                    for i in range(20):
                        x_offset = random.randint(8, 15)
                        y_offset = random.randint(-2, 2)
                        actions.move_by_offset(x_offset, y_offset)
                        actions.pause(random.uniform(0.05, 0.15))
                    
                    actions.release()
                    actions.perform()
                    
                    time.sleep(random.uniform(2, 4))
                    print("‚úÖ Slider CAPTCHA √ß√∂z√ºld√º")
                    return True
                    
                except:
                    continue
            
            return False
            
        except Exception as e:
            self.logger.warning(f"Slider CAPTCHA hatasƒ±: {e}")
            return False
    
    def solve_puzzle_captcha(self):
        """Puzzle (par√ßa birle≈ütirme) CAPTCHA √ß√∂zer"""
        try:
            # Puzzle piece selectors
            puzzle_selectors = [
                "[class*='puzzle']",
                "[class*='jigsaw']",
                ".captcha-puzzle",
                "[id*='puzzle']"
            ]
            
            for selector in puzzle_selectors:
                try:
                    puzzle_piece = self.driver.find_element(By.CSS_SELECTOR, selector)
                    
                    # Puzzle piece'i s√ºr√ºkle
                    actions = ActionChains(self.driver)
                    actions.click_and_hold(puzzle_piece)
                    
                    # Puzzle √ß√∂zme hareketi (genelde saƒüa doƒüru)
                    target_x = random.randint(200, 300)
                    target_y = random.randint(-10, 10)
                    
                    # Yava≈ü hareket
                    steps = 30
                    for i in range(steps):
                        x = target_x / steps
                        y = target_y / steps + random.randint(-1, 1)
                        actions.move_by_offset(x, y)
                        actions.pause(random.uniform(0.02, 0.08))
                    
                    actions.release()
                    actions.perform()
                    
                    time.sleep(random.uniform(2, 4))
                    print("‚úÖ Puzzle CAPTCHA √ß√∂z√ºld√º")
                    return True
                    
                except:
                    continue
            
            return False
            
        except Exception as e:
            self.logger.warning(f"Puzzle CAPTCHA hatasƒ±: {e}")
            return False
    
    def solve_math_captcha(self):
        """Matematik CAPTCHA √ß√∂zer"""
        try:
            # Math CAPTCHA selectors
            math_selectors = [
                "[class*='math']",
                "[class*='calculate']",
                "input[placeholder*='+']",
                "input[placeholder*='=']"
            ]
            
            for selector in math_selectors:
                try:
                    math_input = self.driver.find_element(By.CSS_SELECTOR, selector)
                    
                    # Matematik sorusunu bul
                    parent = math_input.find_element(By.XPATH, "./..")
                    text = parent.text
                    
                    # Basit matematik i≈ülemleri
                    if '+' in text:
                        parts = text.split('+')
                        if len(parts) >= 2:
                            num1 = int(''.join(filter(str.isdigit, parts[0])))
                            num2 = int(''.join(filter(str.isdigit, parts[1])))
                            result = num1 + num2
                            
                            math_input.clear()
                            math_input.send_keys(str(result))
                            
                            time.sleep(random.uniform(1, 2))
                            print(f"‚úÖ Matematik CAPTCHA √ß√∂z√ºld√º: {num1}+{num2}={result}")
                            return True
                    
                except:
                    continue
            
            return False
            
        except Exception as e:
            self.logger.warning(f"Matematik CAPTCHA hatasƒ±: {e}")
            return False
    
    def detect_and_solve_captcha(self):
        """CAPTCHA tespit eder ve otomatik √ß√∂zer"""
        try:
            print("üîç CAPTCHA aranƒ±yor...")
            
            # Farklƒ± CAPTCHA t√ºrlerini sƒ±rayla dene
            captcha_solved = False
            
            # 1. Checkbox CAPTCHA
            if self.solve_checkbox_captcha():
                captcha_solved = True
            
            # 2. Slider CAPTCHA  
            elif self.solve_slider_captcha():
                captcha_solved = True
            
            # 3. Puzzle CAPTCHA
            elif self.solve_puzzle_captcha():
                captcha_solved = True
            
            # 4. Math CAPTCHA
            elif self.solve_math_captcha():
                captcha_solved = True
            
            if captcha_solved:
                time.sleep(random.uniform(3, 5))
                return True
            else:
                print("‚ö†Ô∏è CAPTCHA tipi tanƒ±nmadƒ±, manuel m√ºdahale gerekebilir")
                return False
                
        except Exception as e:
            self.logger.warning(f"CAPTCHA √ß√∂zme hatasƒ±: {e}")
            return False

class GelismisAliExpressBot:
    def __init__(self):
        self.setup_logging()
        self.user_agents = [
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15'
        ]
        self.driver = None
        self.captcha_solver = None
        self.proxy_list = []
        self.current_proxy_index = 0
        
    def setup_logging(self):
        """Log sistemini kurar"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('bot_log.txt', encoding='utf-8'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def get_next_proxy(self):
        """Sƒ±radaki proxy'yi d√∂nd√ºr√ºr"""
        if not self.proxy_list:
            return None
        
        proxy = self.proxy_list[self.current_proxy_index]
        self.current_proxy_index = (self.current_proxy_index + 1) % len(self.proxy_list)
        return proxy
    
    def setup_browser(self, use_proxy=False):
        """Geli≈ümi≈ü browser kurulumu"""
        try:
            print("üåê Geli≈ümi≈ü tarayƒ±cƒ± ba≈ülatƒ±lƒ±yor...")
            
            chrome_options = Options()
            
            # Temel ayarlar
            chrome_options.add_argument('--no-sandbox')
            chrome_options.add_argument('--disable-dev-shm-usage')
            chrome_options.add_argument('--disable-blink-features=AutomationControlled')
            chrome_options.add_argument('--disable-extensions')
            chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
            chrome_options.add_experimental_option('useAutomationExtension', False)
            
            # Anti-detection ayarlarƒ±
            chrome_options.add_argument('--disable-plugins-discovery')
            chrome_options.add_argument('--disable-default-apps')
            chrome_options.add_argument('--disable-background-networking')
            chrome_options.add_argument('--disable-background-timer-throttling')
            chrome_options.add_argument('--disable-renderer-backgrounding')
            chrome_options.add_argument('--disable-backgrounding-occluded-windows')
            
            # Rastgele User-Agent
            user_agent = random.choice(self.user_agents)
            chrome_options.add_argument(f'--user-agent={user_agent}')
            
            # Proxy ayarlarƒ± (eƒüer varsa)
            if use_proxy and self.proxy_list:
                proxy = self.get_next_proxy()
                if proxy:
                    chrome_options.add_argument(f'--proxy-server={proxy}')
                    print(f"üîí Proxy kullanƒ±lƒ±yor: {proxy}")
            
            # Dil ve lokalizasyon
            chrome_options.add_argument('--lang=tr-TR')
            chrome_options.add_experimental_option('prefs', {
                'intl.accept_languages': 'tr-TR,tr,en-US,en',
                'profile.default_content_setting_values.notifications': 2,
                'profile.default_content_settings.popups': 0
            })
            
            # Driver olu≈ütur
            homebrew_paths = [
                "/opt/homebrew/bin/chromedriver",
                "/usr/local/bin/chromedriver"
            ]
            
            driver_created = False
            for path in homebrew_paths:
                if os.path.exists(path):
                    try:
                        service = Service(path)
                        self.driver = webdriver.Chrome(service=service, options=chrome_options)
                        driver_created = True
                        print(f"‚úÖ ChromeDriver ba≈üarƒ±lƒ±: {path}")
                        break
                    except:
                        continue
            
            if not driver_created:
                service = Service(ChromeDriverManager().install())
                self.driver = webdriver.Chrome(service=service, options=chrome_options)
            
            # Browser ayarlarƒ±
            self.driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
            self.driver.execute_cdp_cmd('Network.setUserAgentOverride', {
                "userAgent": user_agent
            })
            
            # CAPTCHA solver'ƒ± ba≈ülat
            self.captcha_solver = OtomatikCaptchaCozucu(self.driver)
            
            print("‚úÖ Geli≈ümi≈ü tarayƒ±cƒ± hazƒ±r")
            return True
            
        except Exception as e:
            print(f"‚ùå Tarayƒ±cƒ± hatasƒ±: {e}")
            return False
    
    def smart_wait(self, min_sec=2, max_sec=6):
        """Akƒ±llƒ± bekleme sistemi"""
        wait_time = random.uniform(min_sec, max_sec)
        print(f"‚è≥ {wait_time:.1f}s bekleniyor...")
        time.sleep(wait_time)
    
    def handle_captcha_automatically(self):
        """Otomatik CAPTCHA i≈üleme"""
        max_attempts = 3
        
        for attempt in range(max_attempts):
            print(f"ü§ñ CAPTCHA √ß√∂zme denemesi {attempt + 1}/{max_attempts}")
            
            if self.captcha_solver.detect_and_solve_captcha():
                print("‚úÖ CAPTCHA otomatik √ß√∂z√ºld√º!")
                return True
            
            if attempt < max_attempts - 1:
                print("‚è≥ Yeniden deneniyor...")
                time.sleep(random.uniform(2, 4))
        
        print("‚ö†Ô∏è Otomatik CAPTCHA √ß√∂zme ba≈üarƒ±sƒ±z - sayfa yenileniyor")
        self.driver.refresh()
        time.sleep(5)
        return False
    
    def detect_captcha(self):
        """CAPTCHA tespiti"""
        try:
            page_source = self.driver.page_source.lower()
            captcha_indicators = [
                'captcha', 'verification', 'verify', 'robot', 'challenge',
                'recaptcha', 'slider', 'puzzle', 'checkbox'
            ]
            
            for indicator in captcha_indicators:
                if indicator in page_source:
                    return True
            
            return False
            
        except:
            return False
    
    def get_product_info_advanced(self, url):
        """Geli≈ümi≈ü √ºr√ºn bilgisi √ßekme"""
        try:
            print(f"üì¶ √úr√ºn sayfasƒ± a√ßƒ±lƒ±yor...")
            
            # Sayfayƒ± a√ß
            self.driver.get(url)
            self.smart_wait(3, 6)
            
            # CAPTCHA kontrol√º ve otomatik √ß√∂zme
            captcha_attempts = 0
            while self.detect_captcha() and captcha_attempts < 3:
                print("ü§ñ CAPTCHA tespit edildi - otomatik √ß√∂z√ºl√ºyor...")
                if self.handle_captcha_automatically():
                    break
                captcha_attempts += 1
                
                if captcha_attempts >= 3:
                    print("‚ö†Ô∏è CAPTCHA √ß√∂z√ºlemedi - √ºr√ºn atlanƒ±yor")
                    return self._create_error_product(url, "CAPTCHA √ß√∂z√ºlemedi")
            
            # Sayfa y√ºklenme kontrol√º
            try:
                WebDriverWait(self.driver, 10).until(
                    lambda driver: driver.execute_script("return document.readyState") == "complete"
                )
            except:
                pass
            
            # ƒ∞nsan benzeri davranƒ±≈ü
            self._human_behavior()
            
            # √úr√ºn bilgilerini √ßek
            product_info = {
                'url': url,
                'name': self._extract_product_name(),
                'price': self._extract_price(),
                'image_url': self._extract_image_url(),
                'rating': self._extract_rating(),
                'sold_count': self._extract_sold_count(),
                'availability': self._extract_availability()
            }
            
            print(f"‚úÖ √úr√ºn bilgisi alƒ±ndƒ±:")
            print(f"   üìù {product_info['name'][:40]}...")
            print(f"   üí∞ {product_info['price']}")
            
            return product_info
            
        except Exception as e:
            print(f"‚ùå √úr√ºn bilgisi hatasƒ±: {e}")
            return self._create_error_product(url, str(e))
    
    def _human_behavior(self):
        """ƒ∞nsan benzeri davranƒ±≈ü sim√ºlasyonu"""
        try:
            # Rastgele scroll
            for _ in range(random.randint(2, 4)):
                scroll_y = random.randint(200, 800)
                self.driver.execute_script(f"window.scrollTo(0, {scroll_y});")
                time.sleep(random.uniform(0.5, 1.5))
            
            # Ba≈üa d√∂n
            self.driver.execute_script("window.scrollTo(0, 0);")
            time.sleep(random.uniform(1, 2))
            
            # Rastgele mouse hareketi
            try:
                actions = ActionChains(self.driver)
                for _ in range(random.randint(1, 3)):
                    x = random.randint(100, 800)
                    y = random.randint(100, 600)
                    actions.move_by_offset(x, y)
                    actions.pause(random.uniform(0.1, 0.5))
                actions.perform()
            except:
                pass
                
        except:
            pass
    
    def _extract_product_name(self):
        """√úr√ºn adƒ±nƒ± √ßƒ±karƒ±r"""
        selectors = [
            "h1[data-pl='product-title']",
            ".product-title-text",
            "h1.x-item-title-label",
            ".pdp-product-name",
            "h1",
            "[class*='title'][class*='product']",
            ".goods-title"
        ]
        
        for selector in selectors:
            try:
                elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                for element in elements:
                    text = element.text.strip()
                    if text and len(text) > 10:
                        return text
            except:
                continue
        
        return "√úr√ºn adƒ± bulunamadƒ±"
    
    def _extract_price(self):
        """Fiyatƒ± √ßƒ±karƒ±r"""
        selectors = [
            ".price-current",
            ".product-price-current", 
            ".notranslate",
            "[class*='price']",
            "[data-pl*='price']",
            ".price-now",
            ".price-original"
        ]
        
        for selector in selectors:
            try:
                elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                for element in elements:
                    text = element.text.strip()
                    if any(symbol in text for symbol in ['$', '‚Ç∫', 'USD', 'TL', '‚Ç¨', '¬•']):
                        return text
            except:
                continue
        
        return "Fiyat bulunamadƒ±"
    
    def _extract_image_url(self):
        """Resim URL'ini √ßƒ±karƒ±r"""
        selectors = [
            "img.magnifier-image",
            "img[class*='image']",
            ".gallery img",
            "img[src*='alicdn']",
            ".product-image img"
        ]
        
        for selector in selectors:
            try:
                img_element = self.driver.find_element(By.CSS_SELECTOR, selector)
                img_url = img_element.get_attribute('src')
                if img_url and ('alicdn' in img_url or 'alibaba' in img_url):
                    return img_url
            except:
                continue
        
        return "Resim bulunamadƒ±"
    
    def _extract_rating(self):
        """Puanƒ± √ßƒ±karƒ±r"""
        selectors = [
            ".summary-star-rate",
            "[class*='rating']",
            "[class*='star']",
            ".product-rate"
        ]
        
        for selector in selectors:
            try:
                element = self.driver.find_element(By.CSS_SELECTOR, selector)
                text = element.text.strip()
                if text and any(char.isdigit() for char in text):
                    return text
            except:
                continue
        
        return "Puan bulunamadƒ±"
    
    def _extract_sold_count(self):
        """Satƒ±≈ü sayƒ±sƒ±nƒ± √ßƒ±karƒ±r"""
        selectors = [
            ".product-reviewer-reviews",
            "[class*='sold']",
            "[class*='order']",
            ".sold-count"
        ]
        
        for selector in selectors:
            try:
                element = self.driver.find_element(By.CSS_SELECTOR, selector)
                text = element.text.strip()
                if text:
                    return text
            except:
                continue
        
        return "Satƒ±≈ü bilgisi yok"
    
    def _extract_availability(self):
        """Stok durumunu √ßƒ±karƒ±r"""
        try:
            page_source = self.driver.page_source.lower()
            
            if any(keyword in page_source for keyword in ['out of stock', 'stokta yok', 't√ºkendi']):
                return "Stokta yok"
            elif any(keyword in page_source for keyword in ['in stock', 'stokta', 'mevcut']):
                return "Stokta var"
            else:
                return "Stok durumu belirsiz"
                
        except:
            return "Stok bilgisi alƒ±namadƒ±"
    
    def _create_error_product(self, url, error):
        """Hata durumu i√ßin √ºr√ºn objesi olu≈üturur"""
        return {
            'url': url,
            'name': f'HATA: {error}',
            'price': 'Hata',
            'image_url': 'Hata',
            'rating': 'Hata',
            'sold_count': 'Hata',
            'availability': 'Hata'
        }
    
    def process_bulk_links(self, input_file='linkler.xlsx', output_file='sonuclar.xlsx', batch_size=100):
        """Toplu link i≈üleme - 6000+ √ºr√ºn i√ßin optimize edilmi≈ü"""
        try:
            print("üìã Excel dosyasƒ± okunuyor...")
            
            if not os.path.exists(input_file):
                print(f"‚ùå {input_file} dosyasƒ± bulunamadƒ±!")
                return False
            
            df = pd.read_excel(input_file)
            
            # S√ºtun adƒ±nƒ± bul
            link_column = None
            possible_names = ['link', 'LINK', 'linkler', 'LINKLER', 'url', 'URL']
            
            for col_name in possible_names:
                if col_name in df.columns:
                    link_column = col_name
                    break
            
            if link_column is None:
                print("‚ùå Link s√ºtunu bulunamadƒ±!")
                return False
            
            print(f"‚úÖ Link s√ºtunu bulundu: '{link_column}'")
            
            # Browser'ƒ± ba≈ülat
            if not self.setup_browser():
                return False
            
            try:
                total_links = len(df)
                results = []
                processed_count = 0
                
                print(f"üìä Toplam {total_links} link i≈ülenecek")
                print(f"üîß Batch boyutu: {batch_size}")
                
                for index, row in df.iterrows():
                    link = row[link_column]
                    
                    if pd.isna(link):
                        continue
                    
                    print(f"\nüì¶ ƒ∞≈üleniyor ({index + 1}/{total_links}) - %{(index+1)/total_links*100:.1f}")
                    print(f"üîó {link[:60]}...")
                    
                    # √úr√ºn bilgisini al
                    product_info = self.get_product_info_advanced(link)
                    results.append(product_info)
                    processed_count += 1
                    
                    # Batch kayƒ±t
                    if processed_count % 10 == 0:
                        temp_df = pd.DataFrame(results)
                        temp_df.to_excel(f"temp_{output_file}", index=False)
                        print(f"üíæ Ge√ßici kayƒ±t: {processed_count} √ºr√ºn")
                    
                    # Browser yenileme (her 50 √ºr√ºnde)
                    if processed_count % 50 == 0:
                        print("üîÑ Browser yenileniyor...")
                        self.driver.quit()
                        time.sleep(random.uniform(3, 7))
                        if not self.setup_browser(use_proxy=True):
                            print("‚ùå Browser yenileme ba≈üarƒ±sƒ±z!")
                            break
                    
                    # Akƒ±llƒ± bekleme
                    if index < total_links - 1:
                        wait_time = random.uniform(2, 6)
                        
                        # Her 100 √ºr√ºnde daha uzun mola
                        if processed_count % 100 == 0:
                            wait_time = random.uniform(30, 60)
                            print(f"‚òï Uzun mola: {wait_time:.0f} saniye")
                        
                        print(f"‚è≥ {wait_time:.1f}s bekleniyor...")
                        time.sleep(wait_time)
                
                # Final kayƒ±t
                print("\nüíæ Final sonu√ßlar kaydediliyor...")
                results_df = pd.DataFrame(results)
                results_df.to_excel(output_file, index=False)
                
                # Ge√ßici dosyayƒ± sil
                temp_file = f"temp_{output_file}"
                if os.path.exists(temp_file):
                    os.remove(temp_file)
                
                print(f"\nüéâ ƒ∞≈ülem tamamlandƒ±!")
                print(f"üìÅ Sonu√ßlar: {output_file}")
                print(f"üìä ƒ∞≈ülenen √ºr√ºn: {processed_count}")
                print(f"‚è±Ô∏è Ba≈üarƒ± oranƒ±: %{(processed_count/total_links)*100:.1f}")
                
                return True
                
            finally:
                if self.driver:
                    self.driver.quit()
                    
        except Exception as e:
            print(f"‚ùå Toplu i≈ülem hatasƒ±: {e}")
            if self.driver:
                self.driver.quit()
            return False

def main():
    print("ü§ñ AliExpress Bot - Otomatik CAPTCHA √á√∂zme")
    print("=" * 60)
    print("‚úÖ 6000+ √ºr√ºn i√ßin optimize edilmi≈ü")
    print("‚úÖ Otomatik CAPTCHA √ß√∂zme")
    print("‚úÖ Akƒ±llƒ± proxy rotasyonu")
    print("‚úÖ Toplu i≈ülem desteƒüi")
    print("=" * 60)
    
    bot = GelismisAliExpressBot()
    
    # Linkler dosyasƒ± kontrol√º
    if not os.path.exists('linkler.xlsx'):
        print("\nüìã linkler.xlsx dosyasƒ± bulunamadƒ±.")
        print("L√ºtfen Excel dosyanƒ±zƒ± olu≈üturun ve tekrar √ßalƒ±≈ütƒ±rƒ±n.")
        return
    
    # ƒ∞≈ülemi ba≈ülat
    print("\nüöÄ Toplu i≈ülem ba≈ülatƒ±lƒ±yor...")
    success = bot.process_bulk_links()
    
    if success:
        print("\n" + "=" * 60)
        print("üéâ T√ºm i≈ülemler ba≈üarƒ±yla tamamlandƒ±!")
        print("üìÅ Sonu√ßlarƒ± sonuclar.xlsx dosyasƒ±nda bulabilirsin.")
        print("=" * 60)
    else:
        print("\n" + "=" * 60)
        print("‚ùå ƒ∞≈ülem sƒ±rasƒ±nda hata olu≈ütu.")
        print("üìÑ Detaylar i√ßin bot_log.txt dosyasƒ±nƒ± kontrol et.")
        print("=" * 60)
    
    input("√áƒ±kmak i√ßin ENTER'a basƒ±n...")

if __name__ == "__main__":
    main()
